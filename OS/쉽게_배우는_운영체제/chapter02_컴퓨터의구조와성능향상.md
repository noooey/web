# Chapter 02 컴퓨터의 구조와 성능 향상

## 하드웨어의 구성
필수장치
- 중앙처리장치(CPU)
- 메인메모리(메모리)

주변장치
- 보조저장장치(저장장치)
- 입력장치
- 출력장치


## 폰노이만 구조
CPU, 메모리, 입출력장치, 저장장치가 **버스로 연결**되어 있는 구조  
모든 프로그램은 **메모리**에 올라와야 실행할 수 있음

- `시스템 버스(FSB)` 메모리와 주변 장치 연결 -> **메모리 속도**
- `CPU 내부 버스(BSB)` CPU 내부 장치 연결 -> **CPU 속도**, (속도: 메모리 << CPU)

## CPU 
### CPU 기본 구성
- `산술논리 연산장치` 산술 연산 및 논리 연산
- `제어장치` 작업 지시
- `레지스터` CPU 내에 데이터 임시 보관

### 레지스터 종류
사용자 가시 레지스터
- `데이터 레지스터(DR)` CPU가 명령어 처리 시 필요한 일반 데이터를 임시로 저장하는 범용 레지스터
- `주소 레지스터(AR)` 데이터 또는 명령어가 저장된 메모리의 주소 저장  

사용자 불가시 레지스터
- `프로그램 카운터(PC)` 다음에 실행할 명령어의 위치 정보
- `명령어 레지스터(IR)` 현재 실행중인 명령어 저장
- `메모리 주소 레지스터(MAR)` 메모리 관리자가 접근해야 할 메모리 주소 저장
- `메모리 버퍼 레지스터(MBR)` 메모리 관리자가 메모리에서 가져온 데이터 임시 저장
- `프로그램 상태 레지스터(PSR)` 연산 결과 저장

### 버스 종류
- `제어 버스` **제어장치** 연결, CPU가 제어 신호를 보내고 작업 결과를 받음 -> **양방향**
- `주소 버스` **MAR**과 연결, 데이터 읽거나 쓸 때 위치 정보를 보냄 -> **단방향**
- `데이터 버스` **MBR**과 연결, 데이터 이동 -> **양방향**

## 메모리
### 메모리 종류
RAM(read and write)
- `휘발성` 메인 메모리에 사용
- `비휘발성`

ROM(read only)

### 메모리 보호
작업이 진행되는 동안 **경계 레지스터**와 **한계 레지스터**의 주소 범위를 벗어나는지 **하드웨어적**으로 점검 -> 벗어나면 **인터럽트** 발생 -> **운영체제**가 해당 프로그램 강제 종료

### 부팅
컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정
![image](https://user-images.githubusercontent.com/66217855/150646409-26621118-c191-41af-a7e4-3c7f653b816d.png)

## 컴퓨터 성능 향상 기술
CPU와 메모리, 프로그램과 하드디스크 등 장치 간 속도 차이의 문제

### 버퍼
일정량의 데이터를 모아 **한꺼번**에 옮김, 두 장치 사이의 속도의 차이 완화  
### 캐시
메모리의 데이터를 **미리** 가져와 저장해주는 임시 장소, CPU와 메모리 간의 속도 차이 완화  
_if_...캐시에 있는 데이터 변경 시,
- `즉시 쓰기` 즉시 메모리에 반영, 메모리에 최신 값 항상 유지, _but_... 성능 하락
- `지연 쓰기` 주기적으로 반영, 성능 향상, _but_... 메모리와 캐시된 데이터 사이의 불일치 발생 가능성O

### 저장 장치의 계층 구조
- CPU와 가까운 쪽에 레지스터나 캐시 배치
- 메모리에서 작업한 내용을 하드디스크와 같이 저렴하고 용량이 큰 저장장치에 영구적으로 저장할 수 있게 함

![image](https://user-images.githubusercontent.com/66217855/150647112-0d601c2b-b31c-4a8b-8283-8ef963562a39.png)

### 인터럽트
CPU의 작업과 저장장치의 데이터 이동을 **독립적**으로 운영 -> 시스템 효율을 높임
1. CPU가 입출력 관리자에게 입출력 명령
2. 입출력 관리자가 명령 받은 데이터를 전송
3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호(인터럽트)를 CPU에 보냄

`직접 메모리 접근` 입출력 관리자가 **CPU의 허락 없이 메모리에 접근**할 수 있는 권한  
`메모리 매핑 입출력` 메모리에서 CPU 작업 영역과 입출력 작업 영역 **분리**

## 병렬 처리
동시에 여러 개의 명령을 처리

### 고려 사항
- 상호 의존성이 없어야 함
- 각 단계의 시간을 거의 일정하게 맞춰야 함
- 적절한 병렬 처리 깊이

### CPU 명령어 실행 과정
1. 명령어 패치(**IF**)
2. 명령어 해석(**ID**)
3. 실행(**EX**)
4. 쓰기(**WB**)

### 병렬 처리 기법
- `파이프라인 기법` **하나의 코어**에 **여러개의 스레드**, 명령어를 여러 단계로 분할 후 각 단계를 동시에 처리하는 하드웨어를 독립적으로 구성
- `슈퍼스칼라 기법` 파이프라인을 처리할 수 있는 **코어를 여러 개** 구성 -> 복수의 명령어 동시 실행
- `슈퍼파이프라인 기법` 파이프라인의 각 단계를 세분화, 한 클록 내에 여러 명령어 처리
- `슈퍼파이프라인 슈퍼스칼라 기법` 
- `VLIW 기법` 소프트웨어적 병렬 처리, 동시에 실행 가능한 명령어들을 하나의 명령어로 압축 실행 

### 파이프라인의 위험
- `데이터 위험` 데이터의 의존성에 의해 발생
- `제어 위험` PC값을 갑자기 변경 시 발생
- `구조 위험` 서로 다른 명령어가 같은 자원에 접근 시 발생