# Chapter 03 프로세스와 스레드

# 01 프로세스의 개요

### 프로그램

**저장장치**에 저장되어 있는 **정적**인 상태

### 프로세스

실행을 위해 **메모리**에 올라온 **동적**인 상태

**프로그램**이 실행되면 **프로세스**가 된다

## 프로그램에서 프로세스로의 전환

어떤 프로그램이 **프로세스** = 운영체제로부터 **프로세스 제어 블록**을 얻음

프로세스 **종료** = 프로세스 제어 블록이 **폐기**

### 프로세스 제어블록(PCB)

프로세스를 **처리**하는 데 필요한 다양한 정보가를 보관하는 **데이터 구조**

- `프로세스 구분자(PID)` 각 프로세스를 구분하는 ID
- `메모리 관련 정보` 메모리 위치 정보, 경계 레지스터 및 한계 레지스터
- `각종 중간값` 프로세스가 사용했던 중간값, 시분할 시스템에서 여러 프로세스가 번갈아가며 실행될 때 사용됨

**운영체제 영역**에 만들어짐, 운영체제가 관리

## 프로세스의 상태

**일괄 작업 시스템**

- 프로세스 **생성**
- CPU를 얻어 **실행**
- 작업을 **완료**하면 종료

**시분할 시스템**의 상태는 일괄 작업 시스템보다 복잡함

### 프로세스의 네 가지 상태

- **생성 상태**  프로세스가 **메모리**에 올라와 실행 준비를 완료한 상태, **프로세스 제어 블록** 생성
- **준비 상태**  **CPU**를 얻을 때까지 기다리는 상태
- **실행 상태**  CPU를 얻어 실제 작업을 수행, 프로세스가 **타임아웃**되면 **준비 상태**로 돌아옴
- **완료 상태**  주어진 시간 동안 작업을 마침, **프로세스 제어 블록 제거**

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled.png)

- `CPU 스케줄러` 프로세스의 전 **상태**를 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 관리
    
    `디스패치` **준비 상태**의 맨 앞의 **프로세스 제어 블록**을 **CPU**에 전달하여 **실행 상태**로 바꾸는 작업
    
    `타임 슬라이스` 프로세스가 실행 상태에서 **배당된 작업 시간**
    
    `타임 아웃` 타임 슬라이스 동안 작업을 끝내지 못하면 **준비 상태**로 돌아감
    
    `클록` **새로운 프로세스**가 들어오면 CPU로부터 **타임 슬라이스 알람을 요청**받고, 타임 슬라이스가 다 되면 **인터럽트**를 사용해 알림
    

### 프로세스의 다섯 가지 상태 (대기 상태 추가, 활성 상태)

프로세스가 **입출력을 요구**하면 CPU가 직접 데이터를 가져오지 않고 **입출력 관리자**에게 명령을 내린다

**입출력 요청 작업이 끝날 때까지** 다음 작업을 할 수 없음 → **효율성 저하**

1. 입출력을 요구한 프로세스를 입출력이 완료될 때까지 **대기 상태**로 옮겨둠
2. CPU 스케줄러가 **준비 상태**에 있는 프로세스 중 하나를 가져다 **실행 상태**로 만듦
3. **대기 상태**의 프로세스는 요청한 입출력이 완료되면 **입출력 관리자**로부터 **인터럽트**를 받고 **준비 상태**로 돌아감
    
    어떤 프로세스가 대기 상태에서 준비 상태로 이동하는 것은 **인터럽트** 때문임
    

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%201.png)

| 상태 | 설명 | 작업 |
| --- | --- | --- |
| 생성 상태 | 프로그램을 메모리에 가져와 실행 준비가 완료된 상태 | 메모리 할당, PCB 생성 |
|  준비 상태 | 실행 대기 중인 모든 프로세스가 차례를 기다리는 상태
PCB는 준비 큐에서 기다리며 CPU 스케줄러에 의해 관리 | dispatch(PID): 준비 → 실행 |
| 실행 상태 | 선택된 프로세스가 타임 슬라이스를 얻어 CPU를 사용하는 상태 (실행 상태 프로세스 개수 == CPU 개수)
프로세스 사이의 문맥 교환 | timeout(PID): 실행 → 준비
exit(PID): 실행 → 완료
block(PID): 실행 → 대기 |
| 대기 상태 | 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될때까지 기다리는 상태
입출력장치별로 마련된 큐에서 대기
입출력이 완료되면 인터럽트 발생 → 해당 인터럽트로 깨어날 프로세스를 찾음(wakeup) → 해당 프로세스의 PCB가 준비 상태로 감 | wakeup(PID): 대기 → 준비 |
| 완료 상태 | 프로세스 종료(정상: exit / 강제: abort)
사용하던 모든 데이터 정리 | 메모리 삭제, PCB 삭제, abort 시 코어 덤프 |

`코어 덤프` **강제 종료**(abort)를 만나면 **디버깅**하기 위해 **직전**의 메모리 상태를 **저장장치**로 옮김

### 휴식 상태와 보류 상태 (활성 상태 외)

- **휴식 상태**  실행을 잠시 멈춘 상태, 프로세스가 **메모리에 그대로**있고 **PCB도 유지**되어 **멈춘 지점에서 재시작** 할 수 있음
- **보류 상태**  프로세스가 **메모리에서 잠시 쫓겨나** **스왑 영역**에 보관됨, 재시작시 **원래** 활성 상태로 돌아감
    - 대기 상태 → **보류 대기 상태**  입출력 완료 시 **보류 준비 상태**로 옮겨 감
    - 준비 상태 → **보류 준비 상태**

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%202.png)

# 02 프로세스 제어 블록과 문맥 교환

## 프로세스 제어 블록 (PCB, TCB)

**모든** 프로세스는 **고유**의 프로세스 제어 블록을 가짐

**프로세스 생성** 시 만들어져서 프로세스가 실행을 **완료**하면 **폐기**됨

### 프로세스 제어 블록 구성

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%203.png)

- `포인터` 준비 상태나 대기 상태의 **큐**를 구현할 때 사용
- `프로세스 상태` 프로세스의 현재 상태
- `프로세스 구분자` 운영체제 내의 여러 프로세스를 구별하기 위한 구분자
- `프로그램 카운터` 다음에 실행될 명령어 위치
- `프로세스 우선순위` 높은 우선순위가 낮은 우선순위보다 먼저 실행, 자주 실행
- `각종 레지스터 정보` 레지스터 중간값
- `메모리 관리 정보` 메모리 위치 정보, 경계 한계 레지스터 값 등
- `할당된 자원 정보` 프로세스 실행을 위한 입출력 자원이나 오픈 파일 정보
- `계정 정보` 계정 번호, CPU 할당 시간 등
- `부모 프로세스 구분자와 자식 프로세스 구분자` PPID(부모), CPID(자식)

### 포인터의 역할

대기 상태에는 **같은 입출력을 요구한 프로세스끼리** 모아놓음

`대기큐` 같은 입출력을 요구하는 프로세스의 프로세스 제어 블록은 동일한 입출력 큐에 모여 있음

이러한 큐를 구현할 때 포인터 사용

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%204.png)

## 문맥 교환

CPU를 차지하던 프로세스가 나가고 **새로운** 프로세스를 받아들이는 작업

두 프로세스의 PCB 교환

- 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용 저장
- 실행 상태로 들어오는 프로세스 제어 블록 내용으로 CPU 다시 세팅

### 문맥 교환의 절차

1. P1이 **타임아웃**되면
    
    P1 프로세스 제어 블록에 **현재까지의 작업 결과가 저장**되고
    
    P1은 **준비 상태**로 쫓겨남
    
2. 준비 상태에 있던 P2가 **실행 상태**로 가면
    
    **CPU 레지스터**가 P2 **프로세스 제어 블록 값**으로 채워져 다음 작업을 하게 됨
    

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%205.png)

문맥 교환 발생

- 타임 아웃
- 인터럽트

# 03 프로세스의 연산

## 프로세스의 구조

| 코드 영역 | 프로그램의 본문이 기술된 곳, 텍스트 영역 | 읽기 전용 |
| --- | --- | --- |
| 데이터 영역 | 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터 | 읽기/쓰기 |
| 스택 영역 | 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터 | 숨김 영역 |

## 프로세스의 생성과 복사

사용자가 **프로그램을 실행**하면 프로세스가 **새로** 생성

1. 운영체제는 프로그램을 **메모리**로 가져와 **코드 영역**에 넣고
2. **프로세스 제어 블록**을 생성함
3. 메모리에 **데이터 영역**과 **스택 영역**을 확보한 후 **프로세스** 실행

### fork()

실행 중인 프로세스로부터 새로운 프로세스를 **복사**하는 함수

커널 제공 시스템 호출 함수

fork() 시스템 호출 사용 시 **실행 중**인 프로세스와 **똑같은** 프로세스가 **하나 더** 만들어짐

프로세스를 복사하면 새로 프로세스를 생성하는 것보다 **훨씬 빠르게** 실행 가능

`부모-자식 관계` **기존**의 프로세스는 **부모 프로세스**가 되고 **새로** 생긴 프로세스는 **자식 프로세스**가 됨

### fork() 동작 과정

fork() 시스템 호출 시 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 생성됨

**PCB**의 일부 내용 **변경**

- 프로세스 구분자(PID) 변경
- 메모리 관련 정보 변경
- 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)가 바뀜
    
    자식 프로세스가 없는 자식 프로세스는 구분자의 값이 -1
    

### fork() 장점

- 프로세스의 생성 속도가 **빠름**
    
    : 기존 메모리에서 복사
    
- **추가 작업 없이 자원을 상속**할 수 있음
- 시스템 관리를 **효율적**으로 할 수 있음
    
    : 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리
    

### fork() 예

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%206.png)

- fork() 문이 **부모 프로세스**에 **0보다 큰 값**을 반환, **자식 프로세스**에 **0**을 반환
    
    만약 **0보다 작은 값**을 반환하면 **자식 프로세스가 생성되지 않은 것**으로 여겨 ‘Error’ cnffur
    
- **fork() 호출 이전**에 파일을 열거나 변수를 선언하면 **모두 자식 프로세스에 상속**됨
- 부모 프로세스와 자식 프로세스는 **서로 독립적**

## 프로세스의 전환

### exec()

**기존의** 프로세스를 **새로운** 프로세스로 **전환**하는 함수

**프로세스는 그대로** 둔 채 **내용만 바꾸는** 시스템 호출

이미 만들어진 프로세스의 구조를 **재활용**

- 프로세스 제어 블록
- 메모리 영역
- 부모-자식 관계 등

### exec()의 동작 과정

- **코드 영역**이 새로운 코드로 바뀜
- **데이터 영역**이 새로운 변수로 채워짐
- **스택 영역**이 리셋

프로세스 제어 블록

- 각종 구분자, 메모리 관련 사항은 **그대로**
- 각종 레지스터와 사용한 파일 정보 모두 **리셋**

### exec() 예

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%207.png)

- **fork()** 실행으로 자식 프로세스 생성
- 부모 프로세스는 0보다 큰 PID를 가짐 → **wait()**에서 **자식 프로세스가 끝날 때까지** 기다림
- 자식 프로세스는 PID가 0값을 가짐 → **execlp()**에서 **코드**가 mplayer로 **바뀌어** 처음부터 다시 실행
- mplayer **실행이 끝나면** **부모 프로세스**의 wait()으로 **돌아옴**
    
    **PCB의 각종 프로세스 구분자**가 **변경되지 않기** 때문에 종료 후에 부모 프로세스로 **돌아올 수 있음**
    

## 프로세스의 계층 구조

### 유닉스 프로세스 계층 구조

유닉스에서 **커널**이 처음 **메모리**에 올라와 **부팅**되면 커널 관련 프로세스를 여러 개 만듦

**운영체제**에 있는 **모든** 프로세스는 `init` 프로세스의 **자식**이 됨

`init` 프로세스는 **일반 사용자** 프로세스의 **맨 위**에 위치

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%208.png)

### 프로세스 계층 구조의 장점

- **여러 작업의 동시 처리**
    - **fork()**를 호출해 `login` 프로세스를 여러 개 만들어 여러 사용자를 동시에 처리
    - **exec()**를 호출해 `login` 프로세스의 구조를 `shell` 프로세스로 재활용
    
    ![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%209.png)
    
- **용이한 자원 회수**
    - **모든** 프로세스를 **부모-자식 관계**로 만들면 **자식 프로세스**가 **작업을 마쳤을 때** 사용하던 **자원**을 **부모 프로세스**가 **회수**하면 됨

### 고아 프로세스 / 좀비 프로세스

- **고아 프로세스**  **부모** 프로세스가 자식보다 **먼저 죽는 경우** 발생
- **좀비 프로세스**  자식 프로세스가 종료했음에도 **부모가 뒤처리를 하지 않을 때**

고아 / 좀비 프로세스가 많아지면 **자원이 낭비**됨

`exit()` / `return()` 자식 프로세스가 **작업이 끝났음**을 부모 프로세스에 **알리는 것**

# 04 스레드

## 스레드의 개념

CPU 스케줄러는 프로세스가 해야 할 일을 CPU에 전달하고 **실제 작업은 CPU가 수행**

프로세스의 코드에 정의된 절차에 따라 **CPU**에 작업 요청을 하는 **실행 단위**

- **프로세스**  **운영체제** 입장에서의 작업 단위, 프로세스 끼리는 **약하게** 연결
    - `멀티태스크` 여러 개의 프로세스, 독립적
- **스레드**  **CPU** 입장에서의 작업 단위, 스레드는 프로세스 내부에서 서로 **강하게** 연결
    - `멀티스레드` 하나의 프로세스에 여러 개의 스레드, 스레드끼리 강하게 연결

- `멀티스레드` 프로세스 내 작업을 여러 개의 스레드로 분할
- `멀티태스킹` 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분 (시분할 시스템)
- `멀티프로세싱` CPU를 여러 개 사용하여 여러 개의 스레드를 동시에 처리
- `CPU 멀티스레드` 파이프라인 기법을 이용해 동시에 여러 스레드를 처리하도록 만든 병렬 처리 기법

## 멀티스레드의 구조와 예

멀티태스킹의 낭비 요소를 제거하기 위해 **스레드**를 사용 → **여러 개**의 일을 **하나의 프로세스** 내에서 함

프로세스

- **동적**인 영역 : 레지스터 값, 스택, 힙 등
- **정적**인 영역 : 코드, 파일 등 → **공유**

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2010.png)

## 멀티스레드의 장단점

### 멀티스레드의 장점

- **응답성 향상**  한 스레드가 **입출력**으로 인해 작업이 진행되지 않더라도 **다른 스레드가 작업**을 계속하여 사용자의 작업 요구에 빨리 응답할 수 있음
- **자원 공유**  한 프로세스 내에서 **독립적인 스레드**를 생성하면 프로세스가 가진 **자원**을 **모든** 스레드가 **공유**하게 되어 작업을 원활하게 진행할 수 있음
- **효율성 향상**  **불필요한 자원의 중복**을 막음
- **다중 CPU 지원**  다중 CPU가 **멀티 스레드를 동시에 처리** → CPU 사용량 증가, 프로세스의 처리 시간 단축

### 멀티스레드의 단점

- **한 스레드**에 **문제**가 생기면 **전체** 프로세스에 **영향**을 미침

## 멀티스레드 모델

### 사용자 스레드 (1 to N)

사용자 레벨에서 라이브러리에 의해 구현된 일반적인 스레드

운영체제가 멀티스레드를 지원하지 않을 때 사용

라이브러리가 커널이 지원하는 스케줄링이나 동기화 같은 기능을 대신 구현해줌

→ 커널 입장에서는 이 스레드는 **하나의 프로세스**처럼 보임

**사용자 프로세스** 내에 **여러 개의 스레드**가 존재하지만 **커널의 스레드 하나**와 연결

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2011.png)

장점

- 문맥 교환과 같은 부가적인 작업이 줄어들어 속도가 빠름

단점

- 여러 개의 스레드가 하나의 커널 스레드와 연결되기 때문에 **커널 스레드**가 입출력 작업을 위해 **대기 상태**에 들어가면 **모든 사용자 스레드**가 같이 **대기**
- **한 프로세스**의 **타임 슬라이스**를 **여러 스레드**가 공유하기 때문에 **여러 개의 CPU를 동시에 사용할 수 없음**
- 보안 취약

### 커널 스레드 (1 to 1)

커널이 직접 생성하고 관리하는 스레드

커널이 멀티스레드를 지원

**하나**의 **사용자 스레드**가 **하나**의 **커널 스레드**와 연결

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2012.png)

장점

- **멀티 CPU** 사용 가능
- **하나**의 스레드가 **대기 상태**에 있어도 **다른** 스레드는 **작업을 계속** 할 수 있음
- 보안에 강함

단점

- **문맥 교환** 시 **오버헤드** 때문에 느리게 작동

### 멀티레벨 스레드 (M to N)

사용자 스레드 + 커널 스레드

사용자 스레드 개수 ≥ 커널 스레드 개수

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2013.png)

장점

- **하나**의 커널 스레드가 **대기 상태**에 들어가면 **다른** 커널 스레드가 **대신 작업**을 하여 유연하게 작업 처리

단점

- 커널 스레드를 같이 사용해 **문맥 교환** 시 **오버헤드**

빠르게 움직여야 하는 스레드 → `사용자 스레드`

안정적으로 움직여야 하는 스레드 → `커널 스레드`

# 05 [심화학습] 동적 할당 영역과 시스템 호출

## 프로세세의 동적 할당 영역

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2014.png)

- **정적 할당 영역**
    
    프로그램 실행 **직전**에 위치와 크기 **결정**
    
    실행되는 동안 **변함 없음**
    
    - 코드 영역
    - 데이터 영역
- **동적 할당 영역**
    
    프로그램 실행되는 동안 크기 **변함 있음**
    
    - 스택 영역
    - 힙 영역

### 스택 영역

`스택` 가장 먼저 들어간(push) 데이터가 가장 나중에 나오는(pop) **후입선출(LIFO)** 방식의 **자료구조**

- 함수 종료 후 복귀 시 **돌아올 메모리 주소**를 저장
- **지역 변수**를 저장

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2015.png)

**프로세스를 작동**하기 위해 **커널**이 유지하는 자료구조

**스레드**가 작동하는 동안 추가되거나 삭제되는 **동적 할당 영역**

### 힙 영역

프로그램이 실행되는 동안 **동적으로 할당**되는 변수 영역

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2016.png)

- **sarr**  프로세스가 **종료될 때까지** 메모리 차지
- **darr**  필요할 때 `malloc()`로 **메모리를 할당** 받았다가 필요 없어지면 `free()`로 메모레 영역 **반환**

## exit()와 wait() 시스템 호출

### exit() 시스템 호출

**자식 프로세스가 끝났음**을 부모 프로세스에게 **알려주는** 시스템 호출

부모 프로세스는 **자식 프로세스가 사용하던 자원**을 빨리 **거둬** 갈 수 있음

정상 종료 **0** / 비정상 종료 **-1** 반환

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2017.png)

### wait() 시스템 호출

**자식 프로세스가 끝나기를 기다렸다가** 자식 프로세스가 종료되면 다음 문장을 실행하는 시스템 호출

**부모 프로세스가 먼저 종료**됨으로써 고아 프로세스가 생기는 것을 **방지**

부모 프로세스와 자식 프로세스 간 **동기화**

![Untitled](Chapter%2003%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20ab7e314138ab4bdcb604e12e860e333d/Untitled%2018.png)